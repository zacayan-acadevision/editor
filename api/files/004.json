[{"tag":"h1","inner":"Funciones de consulta"},{"tag":"md","inner":"Una función de consulta puede ser literalmente cualquier función que **devuelve una promesa**. La promesa que se devuelve debe **resolver los datos o generar un error**.\n\nTodas las siguientes son configuraciones de función de consulta válidas:\n"},{"tag":"html","inner":"1 useQuery(['todos'], fetchAllTodos)\n2 useQuery(['todos', todoId], () => fetchTodoById(todoId))\n3 useQuery(['todos', todoId], async () => {\n4  const data = await fetchTodoById(todoId)\n5  return data\n6 })\n7 useQuery(['todos', todoId], ({ queryKey }) => fetchTodoById(queryKey[1]))\n"},{"tag":"h2","inner":"Manejo y lanzamiento de errores\n"},{"tag":"md","inner":"Para que React Query determine que una consulta ha cometido un error, la función de consulta **debe lanzar**. Cualquier error que se produzca en la función de consulta se conservará en el estado de la consulta. (error)\n"},{"tag":"html","inner":"1 const { error } = useQuery(['todos', todoId], async () => {\n2  if (somethingGoesWrong) {\n3    throw new Error('Oh no!')\n4  }\n5\n6  return data\n7 })\n"},{"tag":"h2","inner":"Uso con y otros clientes que no se lanzan de forma predeterminada (fetch)\n"},{"tag":"md","inner":"Si bien a la mayoría de las utilidades les gustan o arrojan automáticamente errores para llamadas HTTP fallidas, algunas utilidades como no arrojan errores de forma predeterminada. Si ese es el caso, tendrás que tirarlos por tu cuenta. Aquí hay una forma sencilla de hacerlo con la popular API: (axios , graphql-request , fetch , fetch)\n"},{"tag":"html","inner":"1 useQuery(['todos', todoId], async () => {\n2  const response = await fetch('/todos/' + todoId)\n3  if (!response.ok) {\n4    throw new Error('Network response was not ok')\n5  }\n6  return response.json()\n7 })\n"},{"tag":"h2","inner":"Variables de función de consulta"},{"tag":"md","inner":"Las claves de consulta no son solo para identificar de forma única los datos que está obteniendo, sino que también se pasan convenientemente a su función de consulta y, aunque no siempre es necesario, esto hace posible extraer sus funciones de consulta si es necesario:"},{"tag":"html","inner":"1 function Todos({ status, page }) {\n2  const result = useQuery(['todos', { status, page }], fetchTodoList)\n3 }\n4\n5 // Access the key, status and page variables in your query function!\n6 function fetchTodoList({ queryKey }) {\n7  const [_key, { status, page }] = queryKey\n8  return new Promise()\n9 }\n"},{"tag":"h2","inner":"Usar un objeto de consulta en lugar de parámetros"},{"tag":"md","inner":"En cualquier lugar donde la firma sea compatible con la API de React Query, también puede usar un objeto para expresar la misma configuración:([queryKey, queryFn, config])\n"},{"tag":"html","inner":"1 import { useQuery } from 'react-query'\n2\n3 useQuery({\n4  queryKey: ['todo', 7],\n5  queryFn: fetchTodo,\n6  ...config,\n7 })\n"}]