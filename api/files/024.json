[{"tag":"md","inner":"Start..."},{"tag":"md","inner":"React Query admite dos formas de precargar datos en el servidor y pasarlos al queryClient.\n\n- Prefetee los datos usted mismo y páselos como (initialData)\n - Rápido de configurar para casos simples\n - Tiene algunas advertencias\n- Prefetee la consulta en el servidor, deshidrate la memoria caché y rehidratarla en el cliente\n - Requiere un poco más de configuración por adelantado\n"},{"tag":"h2","inner":"Usando Next.js\n"},{"tag":"md","inner":"La implementación exacta de estos mecanismos puede variar de una plataforma a otra, pero recomendamos comenzar con Next.js que admite **2 formas de pre-renderizado:**\n\n- Generación estática (SSG)\n- Representación del lado del servidor (SSR)\n\nReact Query admite ambas formas de pre-renderizado independientemente de la plataforma que esté utilizando\n"},{"tag":"h2","inner":"Usando initialData\n"},{"tag":"md","inner":"Junto con (getStaticProps o getServerSideProps) de Next.js, puede pasar los datos que obtenga en cualquiera de los métodos a la opción 's'. Desde la perspectiva de React Query, estos se integran de la misma manera, se muestra a continuación: (useQuery , initialData , getStaticProps)\n\n"},{"tag":"html","inner":"1 export async function getStaticProps() {\n2  const posts = await getPosts()\n3  return { props: { posts } }\n4 }\n5\n6 function Posts(props) {\n7  const { data } = useQuery('posts', getPosts, { initialData: props.posts })\n8\n9  // ...\n10 }\n"},{"tag":"md","inner":"La configuración es mínima y esta puede ser una solución rápida para algunos casos, pero hay **algunas compensaciones a considerar** en comparación con el enfoque completo:\n\n- Si está llamando a un componente más profundo en el árbol, debe pasar el hacia abajo a ese punto. (useQuery , initialData)\n- Si llama con la misma consulta en varias ubicaciones, debe pasar a todas ellas (useQuery , initialData)\n- No hay forma de saber a qué hora se obtuvo la consulta en el servidor, por lo que determinar si la consulta necesita volver a buscarse se basa en cuándo se cargó la página en su lugar. (dataUpdatedAt)\n"},{"tag":"h2","inner":"Uso de la hidratación\n"},{"tag":"md","inner":"React Query admite la carga previa de varias consultas en el servidor en Next.js y luego deshidratar esas consultas en queryClient. Esto significa que el servidor puede prerenderizar el marcado que está disponible inmediatamente al cargar la página y tan pronto como JS esté disponible, React Query puede actualizar o hidratar esas consultas con la funcionalidad completa de la biblioteca. Esto incluye volver a recuperar esas consultas en el cliente si se han vuelto obsoletas desde el momento en que se procesaron en el servidor.\n\nPara admitir consultas de almacenamiento en caché en el servidor y configurar la hidratación:\n\n- Cree una nueva instancia **dentro de su aplicación y en una referencia de instancia (o en estado React). Esto garantiza que los datos no se compartan entre diferentes usuarios y solicitudes, mientras que solo se crea QueryClient una vez por ciclo de vida del componente**. (QueryClient)\n- Empaquetar el componente de la aplicación y pasarlo a la instancia de cliente (QueryClientProvider)\n- Envuelva el componente de la aplicación con y pásele el accesorio de  (Hydrate , dehydratedState , pageProps)\n"},{"tag":"html","inner":"1 // _app.jsx\n2 import { Hydrate, QueryClient, QueryClientProvider } from 'react-query'\n3\n4 export default function MyApp({ Component, pageProps }) {\n5  const [queryClient] = React.useState(() => new QueryClient())\n6\n7  return (\n8    <QueryClientProvider client={queryClient}>\n9      <Hydrate state={pageProps.dehydratedState}>\n10        <Component {...pageProps} />\n11      </Hydrate>\n12    </QueryClientProvider>\n13  )\n14 }\n"},{"tag":"md","inner":"Ahora está listo para capturar previamente algunos datos en sus páginas con getStaticProps (para SSG) o (getServerSideProps) (para SSR). Desde la perspectiva de React Query, estos se integran de la misma manera, se muestra a continuación. (getStaticProps)\n\n- Cree una nueva instancia **para cada solicitud de página. Esto garantiza que los datos no se compartan entre usuarios y solicitudes**. (QueryClient)\n- Captura previa de los datos mediante el método clients y espera a que se completen (prefetchQuery)\n- Se usa para deshidratar la caché de consultas y pasarla a la página a través del prop. Este es el mismo accesorio del que se recogerá el caché en su  (dehydrate , dehydratedState , _app.js)\n"},{"tag":"html","inner":"1 // pages/posts.jsx\n2 import { dehydrate, QueryClient, useQuery } from 'react-query';\n3\n4 export async function getStaticProps() {\n5  const queryClient = new QueryClient()\n6\n7  await queryClient.prefetchQuery('posts', getPosts)\n8\n9  return {\n10    props: {\n11      dehydratedState: dehydrate(queryClient),\n12    },\n13  }\n14 }\n15\n16 function Posts() {\n17  // This useQuery could just as well happen in some deeper child to\n18  // the \"Posts\"-page, data will be available immediately either way\n19  const { data } = useQuery('posts', getPosts)\n20\n21  // This query was not prefetched on the server and will not start\n22  // fetching until on the client, both patterns are fine to mix\n23  const { data: otherData } = useQuery('posts-2', getPosts)\n24\n25  // ...\n26 }\n"},{"tag":"md","inner":"Como se ha demostrado, está bien capturar previamente algunas consultas y dejar que otras lo busquen en queryClient. Esto significa que puede controlar qué servidor de contenido representa o no agregando o eliminando para una consulta específica. (prefetchQuery)\n"},{"tag":"h2","inner":"Advertencia para Next.js reescrituras\n"},{"tag":"md","inner":"Hay una trampa si está utilizando **la función de reescritura de Next.js** junto con la **optimización estática automática** o: causará una segunda hidratación por React Query. Esto se debe **a que Next.js debe asegurarse de analizar las reescrituras** en el cliente y recopilar los parámetros después de la hidratación para que puedan proporcionarse en . (getStaticProps , router.query)\n\nEl resultado es la falta de igualdad referencial para todos los datos de hidratación, que por ejemplo se activa dondequiera que sus datos se utilicen como accesorios de componentes o en la matriz de dependencia de s / s. (useEffect , useMemo)\n"},{"tag":"h2","inner":"Usar otros marcos o marcos de SSR personalizados\n"},{"tag":"md","inner":"Esta guía es, en el mejor de los casos, una descripción general de alto nivel de cómo debería funcionar SSR con React Query. Su millaje puede variar ya que hay muchas configuraciones posibles diferentes para SSR.\n\nSi puede, por favor contribuya con sus hallazgos a esta página para cualquier orientación específica del marco.\n"},{"tag":"md","inner":"**EN EL SERVIDOR**"},{"tag":"md","inner":"- Cree una nueva instancia **dentro del controlador de solicitudes. Esto garantiza que los datos no se compartan entre diferentes usuarios y solicitudes**. (QueryClient)\n- Usando el cliente, prefetee cualquier dato que necesite\n- Deshidratar al cliente\n- Procese su aplicación con el proveedor del cliente y también **con el estado deshidratado. ¡Esto es extremadamente importante! Debe representar tanto el servidor como el cliente utilizando el mismo estado deshidratado para garantizar que la hidratación en el cliente produzca exactamente el mismo marcado que el servidor**.\n- Serializar e incrustar la caché deshidratada que se enviará al cliente con el HTML\n- Borre las cachés de React Query después de que se haya enviado el estado deshidratado llamando a (queryClient.clear())\n"},{"tag":"md","inner":"**NOTA DE SEGURIDAD**: La serialización de datos con puede ponerlo en riesgo de vulnerabilidades XSS, **esta publicación de blog explica por qué y cómo resolverlo** (JSON.stringify)\n"},{"tag":"html","inner":"1 import { dehydrate, Hydrate, QueryClient, QueryClientProvider } from 'react-query';\n2\n3 function handleRequest (req, res) {\n4  const queryClient = new QueryClient()\n5  await queryClient.prefetchQuery('key', fn)\n6  const dehydratedState = dehydrate(queryClient)\n7\n8  const html = ReactDOM.renderToString(\n9    <QueryClientProvider client={queryClient}>\n10      <Hydrate state={dehydratedState}>\n11        <App />\n12      </Hydrate>\n13    </QueryClientProvider>\n14  )\n15\n16  res.send(`\n17    <html>\n18      <body>\n19        <div id=\"root\">${html}</div>\n20        <script>\n21          window.__REACT_QUERY_STATE__ = ${JSON.stringify(dehydratedState)};\n22        </script>\n23      </body>\n24    </html>\n25  `)\n26\n27  queryClient.clear()\n28 }\n"},{"tag":"md","inner":"**CLIENTE**"},{"tag":"md","inner":"- Analizar el estado de caché deshidratado que se envió al cliente con el HTML\n- Crear una nueva instancia (QueryClient)\n- Procese su aplicación **con el proveedor del cliente y también con el estado deshidratado. ¡Esto es extremadamente importante! Debe representar tanto el servidor como el cliente utilizando el mismo estado deshidratado para garantizar que la hidratación en el cliente produzca exactamente el mismo marcado que el servidor.**\n"},{"tag":"html","inner":"1 import { Hydrate, QueryClient, QueryClientProvider } from 'react-query'\n2\n3 const dehydratedState = window.__REACT_QUERY_STATE__\n4\n5 const queryClient = new QueryClient()\n6\n7 ReactDOM.hydrate(\n8  <QueryClientProvider client={queryClient}>\n9    <Hydrate state={dehydratedState}>\n10      <App />\n11    </Hydrate>\n12  </QueryClientProvider>,\n13  document.getElementById('root')\n14 )\n"},{"tag":"h2","inner":"Consejos, trucos y advertencias\n"},{"tag":"md","inner":"**Solo las consultas correctas se incluyen en la deshidratación**\n\nCualquier consulta con un error se excluye automáticamente de la deshidratación. Esto significa que el comportamiento predeterminado es fingir que estas consultas nunca se cargaron en el servidor, normalmente mostrando un estado de carga en su lugar, y volver a intentar las consultas en queryClient. Esto sucede independientemente del error.\n\nA veces este comportamiento no es deseable, tal vez desee representar una página de error con un código de estado correcto en lugar de ciertos errores o consultas. En esos casos, use y detecte cualquier error para manejarlos manualmente. (fetchQuery)\n\n**La obsolescencia se mide desde el momento en que se obtuvo la consulta en el servidor**\n\nUna consulta se considera obsoleta dependiendo de cuándo fue. Una advertencia aquí es que el servidor debe tener la hora correcta para que esto funcione correctamente, pero se usa la hora UTC, por lo que las zonas horarias no son un factor en esto. (dataUpdatedAt)\n\nDado que el valor predeterminado es , las consultas se volverán a recuperar en segundo plano al cargar la página de forma predeterminada. Es posible que desee usar un superior para evitar esta doble búsqueda, especialmente si no almacena en caché su marcado. (staleTime , 0 , staleTime)\n\n¡Esta recuperación de consultas obsoletas es una combinación perfecta cuando se almacena en caché el marcado en una CDN! Puede establecer el tiempo de caché de la página en sí decentemente alto para evitar tener que volver a representar páginas en el servidor, pero configurar las consultas más bajas para asegurarse de que los datos se recuperen en segundo plano tan pronto como un usuario visite la página. ¿Tal vez desee almacenar en caché las páginas durante una semana, pero recuperar los datos automáticamente al cargar la página si tiene más de un día? (staleTime)\n\n**Alto consumo de memoria en el servidor**\n\nEn caso de que esté creando el para cada solicitud, React Query crea la caché aislada para este cliente, que se conserva en la memoria durante el período (que por defecto es de 5 minutos). Eso puede conducir a un alto consumo de memoria en el servidor en caso de un gran número de solicitudes durante ese período. (QueryClient , cacheTime)\n\nPara borrar la memoria caché después de que no sea necesaria y para reducir el consumo de memoria, puede agregar una llamada a (queryClient.clear())después de que se gestione la solicitud y se haya enviado el estado deshidratado al cliente.\n\nAlternativamente, puede establecer un archivo. (cacheTime)\n"}]