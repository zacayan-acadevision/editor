[{"tag":"h1","inner":"Rebúsqueda de enfoque de ventana\n"},{"tag":"md","inner":"Si un usuario abandona su aplicación y vuelve a los datos obsoletos, **React Query solicita automáticamente datos nuevos en segundo plano**. Puede deshabilitar esto globalmente o por consulta usando la opción: refetchOnWindowFocus\n\n**Desactivación global**\n"},{"tag":"html","inner":"1 //\n2 const queryClient = new QueryClient({\n3  defaultOptions: {\n4    queries: {\n5      refetchOnWindowFocus: false,\n6    },\n7  },\n8 })\n9\n10 function App() {\n11  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n12 }"},{"tag":"md","inner":"**Deshabilitar por consulta**\n"},{"tag":"html","inner":"useQuery('todos', fetchTodos, { refetchOnWindowFocus: false })"},{"tag":"h2","inner":"Evento de enfoque de ventana personalizado\n"},{"tag":"md","inner":"En raras circunstancias, es posible que desee administrar sus propios eventos de enfoque de ventana que activan React Query para revalidar. Para hacer esto, React Query proporciona una función que le proporciona la devolución de llamada que debe activarse cuando la ventana está enfocada y le permite configurar sus propios eventos. Al llamar , se quita el controlador establecido anteriormente (que en la mayoría de los casos será el controlador predeterminado) y en su lugar se utiliza el nuevo controlador. Por ejemplo, este es el controlador predeterminado: (focusManager.setEventListener , focusManager.setEventListener)\n"},{"tag":"html","inner":"1 focusManager.setEventListener(handleFocus => {\n2  // Listen to visibilitychange and focus\n3  if (typeof window !== 'undefined' && window.addEventListener) {\n4    window.addEventListener('visibilitychange', handleFocus, false)\n5    window.addEventListener('focus', handleFocus, false)\n6  }\n7\n8  return () => {\n9    // Be sure to unsubscribe if a new handler is set\n10    window.removeEventListener('visibilitychange', handleFocus)\n11    window.removeEventListener('focus', handleFocus)\n12  }\n13 })\n"},{"tag":"h2","inner":"Ignorar eventos de enfoque de Iframe\n"},{"tag":"md","inner":"Un gran caso de uso para reemplazar el controlador de enfoque es el de los eventos iframe. Los iframes presentan problemas con la detección del enfoque de la ventana mediante eventos de doble disparo y también disparando eventos falsos positivos al enfocar o usar iframes dentro de su aplicación. Si experimenta esto, debe usar un controlador de eventos que omita estos eventos tanto como sea posible. ¡Recomiendo **este**! Se puede configurar de la siguiente manera:\n"},{"tag":"html","inner":"1 import { focusManager } from 'react-query'\n2 import onWindowFocus from './onWindowFocus' // The gist above\n3\n4 focusManager.setEventListener(onWindowFocus) // Boom!\n"},{"tag":"h2","inner":"Gestión del enfoque en React Native\n"},{"tag":"md","inner":"En lugar de escuchar eventos activados, React Native proporciona información de enfoque a través del **módulo** (AppState). Puedes usar el evento \"change\" para activar una actualización cuando el estado de la aplicación cambie a \"active\": (window , AppState)\n"},{"tag":"html","inner":"1 import { AppState } from 'react-native'\n2 import { focusManager } from 'react-query'\n3\n4 focusManager.setEventListener(handleFocus => {\n5  const subscription = AppState.addEventListener('change', state => {\n6    handleFocus(state === 'active')\n7  })\n8\n9  return () => {\n10    subscription.remove()\n11  }\n12 })\n"},{"tag":"h2","inner":"Administración del estado de enfoque\n"},{"tag":"html","inner":"1 import { focusManager } from 'react-query'\n2\n3 // Override the default focus state\n4 focusManager.setFocused(true)\n5\n6 // Fallback to the default focus check\n7 focusManager.setFocused(undefined)"},{"tag":"h2","inner":"Trampas y advertencias\n"},{"tag":"md","inner":"Algunas ventanas de diálogo internas del navegador, como los diálogos generados por o de carga de archivos (creados por ) también pueden desencadenar la recuperación del foco después de cerrarse. Esto puede provocar efectos secundarios no deseados, ya que la recuperación puede desencadenar desmontajes o remontajes de componentes antes de que se ejecute el controlador de carga de archivos. Consulta **este problema en GitHub** para conocer los antecedentes y las posibles soluciones. (alert(), input type=\"file\" /)"}]