[{"tag":"h1","inner":"Mutaciones\n"},{"tag":"md","inner":"A diferencia de las consultas, las mutaciones se utilizan normalmente para crear/actualizar/eliminar datos o realizar efectos secundarios del servidor. Para ello, React Query exporta un gancho. (useMutation)\n\nEste es un ejemplo de una mutación que agrega un nuevo todo al servidor:\n"},{"tag":"html","inner":"1 function App() {\n2  const mutation = useMutation(newTodo => {\n3    return axios.post('/todos', newTodo)\n4  })\n5\n6  return (\n7    <div>\n8      {mutation.isLoading ? (\n9        'Adding todo...'\n10      ) : (\n11        <>\n12          {mutation.isError ? (\n13            <div>An error occurred: {mutation.error.message}</div>\n14          ) : null}\n15\n16          {mutation.isSuccess ? <div>Todo added!</div> : null}\n17\n18          <button\n19            onClick={() => {\n20              mutation.mutate({ id: new Date(), title: 'Do Laundry' })\n21            }}\n22          >\n23            Create Todo\n24          </button>\n25        </>\n26      )}\n27    </div>\n28  )\n29 }\n"},{"tag":"md","inner":"Una mutación solo puede estar en uno de los siguientes estados en un momento dado:\n\n- (isIdle) o - La mutación está actualmente inactiva o en un estado nuevo/restablecido (status === 'idle')\n- (isLoading) o - La mutación se está ejecutando actualmente (status === 'loading')\n- (isError) o - La mutación encontró un error (status === 'error')\n- (isSuccess) o - La mutación fue exitosa y los datos de mutación están disponibles (status === 'success')\n\nMás allá de esos estados primarios, hay más información disponible dependiendo del estado de la mutación:\n\n- (error) - Si la mutación está en un estado, el error está disponible a través de la propiedad. (error , error)\n- (data) - Si la mutación está en un estado, los datos están disponibles a través de la propiedad. (success , data)\n\nEn el ejemplo anterior, también vio que puede pasar variables a su función de mutaciones llamando a la función con una **sola variable u objeto**. (mutate)\n\nIncluso con solo variables, las mutaciones no son tan especiales, pero cuando se usan con la opción, el método (invalidateQueries) **del cliente de** consulta y el **método** (setQueryData) **del cliente de consulta**, las mutaciones se convierten en una herramienta muy poderosa. (onSuccess)\n\n**IMPORTANTE**: La función es una función asíncrona, lo que significa que no puede usarla directamente en una devolución de llamada de evento en **React 16 y versiones anteriores**. Si necesita acceder al evento, debe incluir otra función. Esto se debe a la **agrupación de eventos React**. (mutate , onSubmit , mutate)\n"},{"tag":"html","inner":"1 // This will not work in React 16 and earlier\n2 const CreateTodo = () => {\n3  const mutation = useMutation(event => {\n4    event.preventDefault()\n5    return fetch('/api', new FormData(event.target))\n6  })\n7\n8  return <form onSubmit={mutation.mutate}>...</form>\n9 }\n10\n11 // This will work\n12 const CreateTodo = () => {\n13  const mutation = useMutation(formData => {\n14    return fetch('/api', formData)\n15  })\n16  const onSubmit = event => {\n17    event.preventDefault()\n18    mutation.mutate(new FormData(event.target))\n19  }\n20\n21  return <form onSubmit={onSubmit}>...</form>\n22 }"},{"tag":"h2","inner":"Restablecimiento del estado de mutación\n"},{"tag":"md","inner":"A veces es el caso de que necesita borrar el o de una solicitud de mutación. Para hacer esto, puede usar la función para manejar esto: error , data , reset\n"},{"tag":"html","inner":"1 const CreateTodo = () => {\n2  const [title, setTitle] = useState('')\n3  const mutation = useMutation(createTodo)\n4\n5  const onCreateTodo = e => {\n6    e.preventDefault()\n7    mutation.mutate({ title })\n8  }\n9\n10  return (\n11    <form onSubmit={onCreateTodo}>\n12      {mutation.error && (\n13        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>\n14      )}\n15      <input\n16        type=\"text\"\n17        value={title}\n18        onChange={e => setTitle(e.target.value)}\n19      />\n20      <br />\n21      <button type=\"submit\">Create Todo</button>\n22    </form>\n23  )\n24 }\n"},{"tag":"h2","inner":"Efectos secundarios de la mutación\n"},{"tag":"md","inner":"(useMutation) viene con algunas opciones de ayuda que permiten efectos secundarios rápidos y fáciles en cualquier etapa durante el ciclo de vida de la mutación. Estos son útiles tanto para invalidar como para recuperar consultas después de mutaciones e incluso actualizaciones optimistas.\n"},{"tag":"html","inner":"1 useMutation(addTodo, {\n2  onMutate: variables => {\n3    // A mutation is about to happen!\n4\n5    // Optionally return a context containing data to use when for example rolling back\n6    return { id: 1 }\n7  },\n8  onError: (error, variables, context) => {\n9    // An error happened!\n10    console.log(`rolling back optimistic update with id ${context.id}`)\n11  },\n12  onSuccess: (data, variables, context) => {\n13    // Boom baby!\n14  },\n15  onSettled: (data, error, variables, context) => {\n16    // Error or success... doesn't matter!\n17  },\n18 })\n"},{"tag":"md","inner":"Al devolver una promesa en cualquiera de las funciones de devolución de llamada, primero se esperará antes de llamar a la siguiente devolución de llamada:\n"},{"tag":"html","inner":"1 useMutation(addTodo, {\n2  onSuccess: async () => {\n3    console.log(\"I'm first!\")\n4  },\n5  onSettled: async () => {\n6    console.log(\"I'm second!\")\n7  },\n8 })\n"},{"tag":"md","inner":"Es posible que desee **activar devoluciones de llamada adicionales a las definidas** al llamar a . Esto se puede utilizar para desencadenar efectos secundarios específicos de los componentes. Para ello, puede proporcionar cualquiera de las mismas opciones de devolución de llamada a la función después de la variable de mutación. Entre las anulaciones admitidas se incluyen: y . Tenga en cuenta que esas devoluciones de llamada adicionales no se ejecutarán si su componente se desmonta antes de que finalice la mutación. (useMutation , mutate , mutate , onSuccess , onError , onSettled)"},{"tag":"html","inner":"1 useMutation(addTodo, {\n2  onSuccess: (data, variables, context) => {\n3    // I will fire first\n4  },\n5  onError: (error, variables, context) => {\n6    // I will fire first\n7  },\n8  onSettled: (data, error, variables, context) => {\n9    // I will fire first\n10  },\n11 })\n12\n13 mutate(todo, {\n14  onSuccess: (data, variables, context) => {\n15    // I will fire second!\n16  },\n17  onError: (error, variables, context) => {\n18    // I will fire second!\n19  },\n20  onSettled: (data, error, variables, context) => {\n21    // I will fire second!\n22  },\n23 })"},{"tag":"h2","inner":"Mutaciones consecutivas"},{"tag":"md","inner":"Hay una ligera diferencia en el manejo y las devoluciones de llamada cuando se trata de mutaciones consecutivas. Cuando se pasan a la función, se encenderán solo una vez y solo si el componente aún está montado. Esto se debe al hecho de que el observador de mutación se elimina y se vuelve a suscribir cada vez que se llama a la función. Por el contrario, los controladores ejecutan para cada llamada. (onSuccess , onError , onSettled , mutate , mutate , useMutation , mutate)\n\nTenga en cuenta que lo más probable es que pase a es asíncrono. En ese caso, el orden en que se cumplen las mutaciones puede diferir del orden de las llamadas a la función. (mutationFn , useMutation , mutate)\n"},{"tag":"html","inner":"1 useMutation(addTodo, {\n2  onSuccess: (data, error, variables, context) => {\n3    // Will be called 3 times\n4  },\n5 })\n6\n7 ['Todo 1', 'Todo 2', 'Todo 3'].forEach((todo) => {\n8  mutate(todo, {\n9    onSuccess: (data, error, variables, context) => {\n10      // Will execute only once, for the last mutation (Todo 3),\n11      // regardless which mutation resolves first\n12    },\n13  })\n14 })\n"},{"tag":"h2","inner":"Promesas"},{"tag":"md","inner":"Use en lugar de para obtener una promesa que se resolverá con éxito o arrojará un error. Esto se puede utilizar, por ejemplo, para componer efectos secundarios. (mutateAsync , mutate)\n"},{"tag":"html","inner":"1 const mutation = useMutation(addTodo)\n2\n3 try {\n4  const todo = await mutation.mutateAsync(todo)\n5  console.log(todo)\n6 } catch (error) {\n7  console.error(error)\n8 } finally {\n9  console.log('done')\n10 }\n"},{"tag":"h2","inner":"Reintentar"},{"tag":"md","inner":"De forma predeterminada, React Query no reintentará una mutación por error, pero es posible con la opción: (retry)\n"},{"tag":"html","inner":"1 const mutation = useMutation(addTodo, {\n2  retry: 3,\n3 })\n"},{"tag":"md","inner":"Si las mutaciones fallan porque el dispositivo está fuera de línea, se volverán a intentar en el mismo orden cuando el dispositivo se vuelva a conectar.\n"},{"tag":"h2","inner":"Mutaciones persistentes\n"},{"tag":"md","inner":"Las mutaciones pueden persistir hasta el almacenamiento si es necesario y reanudarse en un momento posterior. Esto se puede hacer con las funciones de hidratación:\n"},{"tag":"html","inner":"1 const queryClient = new QueryClient()\n2\n3 // Define the \"addTodo\" mutation\n4 queryClient.setMutationDefaults('addTodo', {\n5  mutationFn: addTodo,\n6  onMutate: async (variables) => {\n7    // Cancel current queries for the todos list\n8    await queryClient.cancelQueries('todos')\n9\n10    // Create optimistic todo\n11    const optimisticTodo = { id: uuid(), title: variables.title }\n12\n13    // Add optimistic todo to todos list\n14    queryClient.setQueryData('todos', old => [...old, optimisticTodo])\n15\n16    // Return context with the optimistic todo\n17    return { optimisticTodo }\n18  },\n19  onSuccess: (result, variables, context) => {\n20    // Replace optimistic todo in the todos list with the result\n21    queryClient.setQueryData('todos', old => old.map(todo => todo.id === context.optimisticTodo.id ? result : todo))\n22  },\n23  onError: (error, variables, context) => {\n24    // Remove optimistic todo from the todos list\n25    queryClient.setQueryData('todos', old => old.filter(todo => todo.id !== context.optimisticTodo.id))\n26  },\n27  retry: 3,\n28 })\n29\n30 // Start mutation in some component:\n31 const mutation = useMutation('addTodo')\n32 mutation.mutate({ title: 'title' })\n33\n34 // If the mutation has been paused because the device is for example offline,\n35 // Then the paused mutation can be dehydrated when the application quits:\n36 const state = dehydrate(queryClient)\n37\n38 // The mutation can then be hydrated again when the application is started:\n39 hydrate(queryClient, state)\n40\n41 // Resume the paused mutations:\n42 queryClient.resumePausedMutations()"},{"tag":"h2","inner":"Lecturas adicionales\n"},{"tag":"md","inner":"Para obtener más información sobre las mutaciones, eche un vistazo a **#12: Dominar mutaciones en React Query** de los Recursos de la Comunidad.\n\n"}]