[{"tag":"h1","inner":"Ensayo"},{"tag":"md","inner":"React Query funciona por medio de ganchos, ya sean los que ofrecemos o los personalizados que los envuelven.\n\nLa escritura de pruebas unitarias para estos ganchos personalizados se puede realizar mediante la biblioteca de **pruebas de React Hooks**.\n\nInstale esto ejecutando:\n"},{"tag":"html","inner":"npm install @testing-library/react-hooks react-test-renderer --save-dev\n"},{"tag":"md","inner":"(La biblioteca es necesaria como una dependencia del mismo nivel de , y debe corresponder a la versión de React que está utilizando). (react-test-renderer , @testing-library/react-hooks)\n"},{"tag":"h2","inner":"Nuestra primera prueba\n"},{"tag":"md","inner":"Una vez instalado, se puede escribir una prueba simple. Dado el siguiente gancho personalizado:\n"},{"tag":"html","inner":"1 export function useCustomHook() {\n2  return useQuery('customHook', () => 'Hello');\n3 }\n"},{"tag":"md","inner":"Podemos escribir una prueba para esto de la siguiente manera:\n"},{"tag":"html","inner":"1 const queryClient = new QueryClient();\n2 const wrapper = ({ children }) => (\n3  <QueryClientProvider client={queryClient}>\n4    {children}\n5  </QueryClientProvider>\n6 );\n7\n8 const { result, waitFor } = renderHook(() => useCustomHook(), { wrapper });\n9\n10 await waitFor(() => result.current.isSuccess);\n11\n12 expect(result.current.data).toEqual(\"Hello\");\n"},{"tag":"md","inner":"Tenga en cuenta que proporcionamos un contenedor personalizado que compila el archivo . Esto ayuda a garantizar que nuestra prueba esté completamente aislada de cualquier otra prueba. (QueryClient , QueryClientProvider)\n\nEs posible escribir este contenedor solo una vez, pero si es así, debemos asegurarnos de que se borre antes de cada prueba, y que las pruebas no se ejecuten en paralelo, de lo contrario, una prueba influirá en los resultados de otras. (QueryClient)\n"},{"tag":"h2","inner":"Desactivar reintentos\n"},{"tag":"md","inner":"La biblioteca utiliza de forma predeterminada tres reintentos con retroceso exponencial, lo que significa que es probable que se agote el tiempo de espera de las pruebas si desea probar una consulta errónea. La forma más sencilla de desactivar los reintentos es a través de QueryClientProvider. Extendamos el ejemplo anterior:\n"},{"tag":"html","inner":"1 const queryClient = new QueryClient({\n2  defaultOptions: {\n3    queries: {\n4      // ✅ turns retries off\n5      retry: false,\n6    },\n7  },\n8 })\n9 const wrapper = ({ children }) => (\n10  <QueryClientProvider client={queryClient}>\n11    {children}\n12  </QueryClientProvider>\n13 );\n"},{"tag":"md","inner":"Esto establecerá los valores predeterminados para todas las consultas en el árbol de componentes en \"sin reintentos\". Es importante saber que esto solo funcionará si su useQuery real no tiene reintentos explícitos establecidos. Si tiene una consulta que desea 5 reintentos, esto seguirá teniendo prioridad, ya que los valores predeterminados solo se toman como reserva.\n"},{"tag":"h2","inner":"Desactivar el registro de errores de red\n"},{"tag":"md","inner":"Al realizar pruebas, queremos suprimir los errores de red que se registran en la consola. Para ello, podemos utilizar la función de. (react-query , setLogger())\n"},{"tag":"html","inner":"1 // as part of your test setup\n2 import { setLogger } from 'react-query'\n3\n4 setLogger({\n5  log: console.log,\n6  warn: console.warn,\n7  // ✅ no more errors on the console\n8  error: () => {},\n9 })\n"},{"tag":"h2","inner":"Establecer cacheTime en Infinity con Jest\n"},{"tag":"md","inner":"(cacheTime) se establece en 5 minutos de forma predeterminada. Esto significa que el temporizador del recolector de basura de caché se activará cada 5 minutos. Si usa Jest, puede establecer el mensaje de error para evitar que \"Jest no se cierre un segundo después de que se complete la ejecución de la prueba\". (cacheTime , Infinity)\n"},{"tag":"h2","inner":"Prueba de llamadas de red\n"},{"tag":"md","inner":"El uso principal de React Query es almacenar en caché las solicitudes de red, por lo que es importante que podamos probar que nuestro código está haciendo las solicitudes de red correctas en primer lugar.\n\nHay muchas maneras de probarlos, pero para este ejemplo vamos a usar **nock**.\n\nDado el siguiente gancho personalizado:\n"},{"tag":"html","inner":"1 function useFetchData() {\n2  return useQuery('fetchData', () => request('/api/data'));\n3 }\n"},{"tag":"md","inner":"Podemos escribir una prueba para esto de la siguiente manera:\n"},{"tag":"html","inner":"1 const queryClient = new QueryClient();\n2 const wrapper = ({ children }) => (\n3  <QueryClientProvider client={queryClient}>\n4    {children}\n5  </QueryClientProvider>\n6 );\n7\n8 const expectation = nock('http://example.com')\n9  .get('/api/data')\n10  .reply(200, {\n11    answer: 42\n12  });\n13\n14 const { result, waitFor } = renderHook(() => useFetchData(), { wrapper });\n15\n16 await waitFor(() => {\n17  return result.current.isSuccess;\n18 });\n19\n20 expect(result.current.data).toEqual({answer: 42});"},{"tag":"md","inner":"Aquí estamos haciendo uso y esperando hasta que el estado de la consulta indique que la solicitud se ha realizado correctamente. De esta manera sabemos que nuestro gancho ha terminado y debe tener los datos correctos. (waitFor)\n"},{"tag":"h2","inner":"Prueba de carga más / Desplazamiento infinito\n"},{"tag":"md","inner":"Primero tenemos que burlarnos de nuestra respuesta API\n"},{"tag":"html","inner":"1 function generateMockedResponse(page) {\n2  return {\n3    page: page,\n4    items: [...]\n5  }\n6 }\n"},{"tag":"md","inner":"Luego, nuestra configuración debe diferenciar las respuestas según la página, y lo usaremos para hacerlo. El valor de aquí será algo así como o  (nock , uri , uri\"/?page=1 , /?page=2)\n"},{"tag":"html","inner":"1 const expectation = nock('http://example.com')\n2  .persist()\n3  .query(true)\n4  .get('/api/data')\n5  .reply(200, (uri) => {\n6    const url = new URL(`http://example.com${uri}`);\n7    const { page } = Object.fromEntries(url.searchParams);\n8    return generateMockedResponse(page);\n9  });\n"},{"tag":"md","inner":"(Observe el , porque llamaremos desde este extremo varias veces). (persist())\n\nAhora podemos ejecutar nuestras pruebas de forma segura, el truco aquí es esperar tanto y luego después de llamar: (isFetching , !isFetching , fetchNextPage())\n"},{"tag":"html","inner":"1 const { result, waitFor } = renderHook(() => useInfiniteQueryCustomHook(), { wrapper });\n2\n3 await waitFor(() => result.current.isSuccess);\n4\n5 expect(result.current.data.pages).toStrictEqual(generateMockedResponse(1));\n6\n7 result.current.fetchNextPage();\n8\n9 await waitFor(() => result.current.isFetching);\n10 await waitFor(() => !result.current.isFetching);\n11\n12 expect(result.current.data.pages).toStrictEqual([\n13  ...generateMockedResponse(1),\n14  ...generateMockedResponse(2),\n15 ]);\n16\n17 expectation.done();\n"},{"tag":"h2","inner":"Lecturas adicionales\n"},{"tag":"md","inner":"Para obtener consejos adicionales y una configuración alternativa utilizando , eche un vistazo a **Testing React Query** de los Recursos de la Comunidad. (mock-service-worker)\n"}]