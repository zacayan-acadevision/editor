[{"tag":"h1","inner":"Datos de consulta iniciales\n"},{"tag":"md","inner":"Hay muchas maneras de proporcionar datos iniciales para una consulta a la memoria caché antes de que la necesite:\n\n- Declarativamente:\n - Proporcionar a una consulta para rellenar previamente su caché si está vacía (initialData)\n- Imperativamente:\n - **Captura previa de los datos mediante** (queryClient.prefetchQuery)\n - **Colocar manualmente los datos en la memoria caché mediante**  (queryClient.setQueryData)\n"},{"tag":"h2","inner":"Usar para rellenar previamente una consulta (initialData)\n"},{"tag":"md","inner":"Puede haber ocasiones en las que ya tenga los datos iniciales de una consulta disponibles en su aplicación y simplemente pueda proporcionarlos directamente a su consulta. Si este es el caso, puede usar la opción para establecer los datos iniciales para una consulta y omitir el estado de carga inicial. (config.initialData)"},{"tag":"md","inner":"**IMPORTANTE**: se conserva en la memoria caché, por lo que no se recomienda proporcionar marcador de posición, datos parciales o incompletos a esta opción y en su lugar utilizar (initialData , placeholderData)\n"},{"tag":"html","inner":"1 function Todos() {\n2  const result = useQuery('todos', () => fetch('/todos'), {\n3    initialData: initialTodos,\n4  })\n5 }\n"},{"tag":"h2","inner":"(staleTime y initialDataUpdatedAt)\n"},{"tag":"md","inner":"Por defecto, se trata como totalmente fresco, como si se acabara de buscar. Esto también significa que afectará la forma en que se interpreta por la opción. (initialData , staleTime)\n\n- Si configura el observador de consulta con , y no (el valor predeterminado), la consulta se recuperará inmediatamente cuando se monte: (initialData , staleTime , staleTime: 0)\n"},{"tag":"html","inner":"\n1 function Todos() {\n2  // Will show initialTodos immediately, but also immediately refetch todos after mount\n3  const result = useQuery('todos', () => fetch('/todos'), {\n4    initialData: initialTodos,\n5  })\n6 }\n"},{"tag":"md","inner":"- Si configura el observador de consulta con y a de ms, los datos se considerarán nuevos durante el mismo período de tiempo, como si solo se obtuvieran de la función de consulta. (initialData , staleTime , 1000)\n"},{"tag":"html","inner":"1 function Todos() {\n2  // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\n3  const result = useQuery('todos', () => fetch('/todos'), {\n4    initialData: initialTodos,\n5    staleTime: 1000,\n6  })\n7 }"},{"tag":"md","inner":"- Entonces, ¿qué pasa si no estás totalmente fresco? Eso nos deja con la última configuración que en realidad es la más precisa y utiliza una opción llamada . Esta opción le permite pasar una marca de tiempo JS numérica en milisegundos de cuándo se actualizó por última vez initialData, por ejemplo, lo que proporciona. Tenga en cuenta que si tiene una marca de tiempo unix, deberá convertirla en una marca de tiempo JS multiplicándola por . (initialData , initialDataUpdatedAt , Date.now(), 1000)"},{"tag":"html","inner":"1 function Todos() {\n2  // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\n3  const result = useQuery('todos', () => fetch('/todos'), {\n4    initialData: initialTodos,\n5    staleTime: 60 * 1000 // 1 minute\n6    // This could be 10 seconds ago or 10 minutes ago\n7    initialDataUpdatedAt: initialTodosUpdatedTimestamp // eg. 1608412420052\n8  })\n9 }\n"},{"tag":"md","inner":"Esta opción permite que staleTime se utilice para su propósito original, determinando qué tan frescos deben ser los datos, al tiempo que permite que los datos se vuelvan a recuperar en el montaje si el es anterior al . En el ejemplo anterior, nuestros datos deben estar actualizados en 1 minuto, y podemos sugerir a la consulta cuándo se actualizó initialData por última vez para que la consulta pueda decidir por sí misma si los datos deben recuperarse nuevamente o no. (initialData , staleTime)\n"},{"tag":"md","inner":"Si prefiere tratar sus datos como **datos previamente cargados**, le recomendamos que use las API o para rellenar la caché de antemano, lo que le permite configurar su independientemente de su inicialData (prefetchQuery , fetchQuery , staleTime)"},{"tag":"h2","inner":"Función de datos inicial\n"},{"tag":"md","inner":"Si el proceso para acceder a los datos iniciales de una consulta es intensivo o simplemente no es algo que desee realizar en cada representación, puede pasar una función como valor. Esta función se ejecutará solo una vez cuando se inicialice la consulta, ahorrándole memoria y / o CPU valiosas: (initialData)\n"},{"tag":"html","inner":"1 function Todos() {\n2  const result = useQuery('todos', () => fetch('/todos'), {\n3    initialData: () => {\n4      return getExpensiveTodos()\n5    },\n6  })\n7 }\n"},{"tag":"h2","inner":"Datos iniciales de la memoria caché\n"},{"tag":"md","inner":"En algunas circunstancias, es posible que pueda proporcionar los datos iniciales de una consulta a partir del resultado almacenado en caché de otra. Un buen ejemplo de esto sería buscar en los datos almacenados en caché de una consulta de lista de todos un elemento de tareas individuales, y luego usarlo como datos iniciales para su consulta de tareas pendientes individual:\n"},{"tag":"html","inner":"1 function Todo({ todoId }) {\n2  const result = useQuery(['todo', todoId], () => fetch('/todos'), {\n3    initialData: () => {\n4      // Use a todo from the 'todos' query as the initial data for this todo query\n5      return queryClient.getQueryData('todos')?.find(d => d.id === todoId)\n6    },\n7  })\n8 }\n"},{"tag":"h2","inner":"Datos iniciales de la memoria caché con (initialDataUpdatedAt)\n"},{"tag":"md","inner":"Obtener datos iniciales de la memoria caché significa que la consulta de origen que está utilizando para buscar los datos iniciales es probablemente antigua, pero . En lugar de usar un artificial para evitar que la consulta se vuelva a obtener inmediatamente, se sugiere que pase la consulta de origen a . Esto proporciona a la instancia de consulta toda la información que necesita para determinar si la consulta debe modificarse y cuándo, independientemente de los datos iniciales que se proporcionen. (initialData , staleTime , dataUpdatedAt , initialDataUpdatedAt)"},{"tag":"html","inner":"1 function Todo({ todoId }) {\n2  const result = useQuery(['todo', todoId], () => fetch(`/todos/${todoId}`), {\n3    initialData: () =>\n4      queryClient.getQueryData('todos')?.find(d => d.id === todoId),\n5    initialDataUpdatedAt: () =>\n6      queryClient.getQueryState('todos')?.dataUpdatedAt,\n7  })\n8 }\n"},{"tag":"h2","inner":"Datos iniciales condicionales de la memoria caché\n"},{"tag":"md","inner":"Si la consulta de origen que está utilizando para buscar los datos iniciales es antigua, es posible que no desee usar los datos almacenados en caché en absoluto y simplemente obtener del servidor. Para facilitar esta decisión, puede usar el método para obtener más información sobre la consulta de origen, incluida una marca de tiempo que puede usar para decidir si la consulta es lo suficientemente \"nueva\" para sus necesidades: (queryClient.getQueryState , state.dataUpdatedAt)"},{"tag":"html","inner":"1 function Todo({ todoId }) {\n2  const result = useQuery(['todo', todoId], () => fetch(`/todos/${todoId}`), {\n3    initialData: () => {\n4      // Get the query state\n5      const state = queryClient.getQueryState('todos')\n6\n7      // If the query exists and has data that is no older than 10 seconds...\n8      if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {\n9        // return the individual todo\n10        return state.data.find(d => d.id === todoId)\n11      }\n12\n13      // Otherwise, return undefined and let it fetch from a hard loading state!\n14    },\n15  })\n16 }\n"},{"tag":"h2","inner":"Lecturas adicionales\n"},{"tag":"md","inner":"Para una comparación entre y , eche un vistazo a los **Recursos de la comunidad**. (Initial Data , Placeholder Data)\n\n"}]