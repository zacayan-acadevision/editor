[{"tag":"h1","inner":"Actualizaciones optimistas\n"},{"tag":"md","inner":"Cuando actualiza con optimismo su estado antes de realizar una mutación, existe la posibilidad de que la mutación falle. En la mayoría de estos casos de error, puede desencadenar una recuperación de sus consultas optimistas para revertirlas a su verdadero estado de servidor. Sin embargo, en algunas circunstancias, la recuperación puede no funcionar correctamente y el error de mutación podría representar algún tipo de problema del servidor que no permitirá volver a buscar. En este caso, puede optar por revertir la actualización.\n\nPara ello, la opción de controlador de le permite devolver un valor que luego se pasará a ambos y controladores como último argumento. En la mayoría de los casos, es más útil pasar una función de reversión. (useMutation , onMutate , onError , onSettled)\n"},{"tag":"h2","inner":"Actualizar una lista de todos al agregar una nueva tarea pendiente\n"},{"tag":"html","inner":"1 const queryClient = useQueryClient()\n2\n3 useMutation(updateTodo, {\n4  // When mutate is called:\n5  onMutate: async newTodo => {\n6    // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n7    await queryClient.cancelQueries('todos')\n8\n9    // Snapshot the previous value\n10    const previousTodos = queryClient.getQueryData('todos')\n11\n12    // Optimistically update to the new value\n13    queryClient.setQueryData('todos', old => [...old, newTodo])\n14\n15    // Return a context object with the snapshotted value\n16    return { previousTodos }\n17  },\n18  // If the mutation fails, use the context returned from onMutate to roll back\n19  onError: (err, newTodo, context) => {\n20    queryClient.setQueryData('todos', context.previousTodos)\n21  },\n22  // Always refetch after error or success:\n23  onSettled: () => {\n24    queryClient.invalidateQueries('todos')\n25  },\n26 })\n"},{"tag":"h2","inner":"Actualización de una sola tarea pendiente\n"},{"tag":"html","inner":"1 useMutation(updateTodo, {\n2  // When mutate is called:\n3  onMutate: async newTodo => {\n4    // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n5    await queryClient.cancelQueries(['todos', newTodo.id])\n6\n7    // Snapshot the previous value\n8    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])\n9\n10    // Optimistically update to the new value\n11    queryClient.setQueryData(['todos', newTodo.id], newTodo)\n12\n13    // Return a context with the previous and new todo\n14    return { previousTodo, newTodo }\n15  },\n16  // If the mutation fails, use the context we returned above\n17  onError: (err, newTodo, context) => {\n18    queryClient.setQueryData(\n19      ['todos', context.newTodo.id],\n20      context.previousTodo\n21    )\n22  },\n23  // Always refetch after error or success:\n24  onSettled: newTodo => {\n25    queryClient.invalidateQueries(['todos', newTodo.id])\n26  },\n27 })\n"},{"tag":"md","inner":"También puede utilizar la función en lugar de los controladores separados y si lo desea: (onSettled , onError , onSuccess)\n"},{"tag":"html","inner":"1 useMutation(updateTodo, {\n2  // ...\n3  onSettled: (newTodo, error, variables, context) => {\n4    if (error) {\n5      // do something\n6    }\n7  },\n8 })\n"}]