[{"tag":"h1","inner":"Consultas paginadas / retrasadas"},{"tag":"p","inner":"La representación de datos paginados es un patrón de interfaz de usuario muy común y en React Query, \"simplemente funciona\" al incluir la información de la página en la clave de consulta:"},{"tag":"gdscript","inner":"const result = useQuery(['projects', page], fetchProjects)"},{"tag":"p","inner":"Sin embargo, si ejecuta este sencillo ejemplo, es posible que observe algo extraño:"},{"tag":"md","inner":"**La interfaz de usuario entra y sale de los estados de (éxito y carga) porque cada nueva página se trata como una consulta nueva.**"},{"tag":"md","inner":"Esta experiencia no es óptima y desafortunadamente es como muchas herramientas hoy en día insisten en funcionar. ¡Pero no React Query! Como habrás adivinado, React Query viene con una característica increíble llamada que nos permite evitar esto. (keepPreviousData)"},{"tag":"h2","inner":"Consultas mejor paginadas con keepPreviousData"},{"tag":"md","inner":"Considere el siguiente ejemplo en el que idealmente querríamos incrementar un pageIndex (o cursor) para una consulta. Si tuviéramos que usar , **técnicamente seguiría funcionando bien**, pero la interfaz de usuario entraría y saldría de los estados y a medida que se crean y destruyen diferentes consultas para cada página o cursor. Al configurar a obtenemos algunas cosas nuevas: (useQuery , success , loading , keepPreviousData , true)\n"},{"tag":"md","inner":"- Los datos de **la última captura correcta están disponibles mientras se solicitan nuevos datos, aunque la clave de consulta haya cambiado.**\n- Cuando llegan los nuevos datos, los anteriores se intercambian sin problemas para mostrar los nuevos datos. (data)\n- (isPreviousData) está disponible para saber qué datos le proporciona actualmente la consulta\n"},{"tag":"gdscript","inner":"\n1 function Todos() {\n2  const [page, setPage] = React.useState(0)\n3\n4  const fetchProjects = (page = 0) => fetch('/api/projects?page=' + page).then((res) => res.json())\n5\n6  const {\n7    isLoading,\n8    isError,\n9    error,\n10    data,\n11    isFetching,\n12    isPreviousData,\n13  } = useQuery(['projects', page], () => fetchProjects(page), { keepPreviousData : true })\n14\n15  return (\n16    <div>\n17      {isLoading ? (\n18        <div>Loading...</div>\n19      ) : isError ? (\n20        <div>Error: {error.message}</div>\n21      ) : (\n22        <div>\n23          {data.projects.map(project => (\n24            <p key={project.id}>{project.name}</p>\n25          ))}\n26        </div>\n27      )}\n28      <span>Current Page: {page + 1}</span>\n29      <button\n30        onClick={() => setPage(old => Math.max(old - 1, 0))}\n31        disabled={page === 0}\n32      >\n33        Previous Page\n34      </button>{' '}\n35      <button\n36        onClick={() => {\n37          if (!isPreviousData && data.hasMore) {\n38            setPage(old => old + 1)\n39          }\n40        }}\n41        // Disable the Next Page button until we know a next page is available\n42        disabled={isPreviousData || !data?.hasMore}\n43      >\n44        Next Page\n45      </button>\n46      {isFetching ? <span> Loading...</span> : null}{' '}\n47    </div>\n48  )\n49 }"},{"tag":"h2","inner":"\nResultados de consultas infinitas retrasadas con keepPreviousData"},{"tag":"p","inner":"Aunque no es tan común, la opción también funciona perfectamente con el gancho, por lo que puede permitir sin problemas que sus usuarios continúen viendo datos almacenados en caché mientras las claves de consulta infinitas cambian con el tiempo."},{"tag":"p","inner":"(keepPreviousData , useInfiniteQuery)"}]