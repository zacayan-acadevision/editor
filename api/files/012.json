[{"tag":"h1","inner":"Consultas infinitas\n"},{"tag":"md","inner":"Las listas de representación que pueden \"cargar más\" datos de forma aditiva en un conjunto de datos existente o \"desplazamiento infinito\" también es un patrón de interfaz de usuario muy común. React Query admite una versión útil de llamadas para consultar este tipo de listas. (useQuery , useInfiniteQuery)\n\nAl usar , notará que algunas cosas son diferentes: (useInfiniteQuery)\n\n- (data) es ahora un objeto que contiene infinitos datos de consulta:\n- (data.pages) matriz que contiene las páginas recuperadas\n- (data.pageParams) matriz que contiene los parámetros de página utilizados para capturar las páginas\n- Las funciones y ya están disponibles (fetchNextPage , fetchPreviousPage)\n- Las opciones y están disponibles tanto para determinar si hay más datos para cargar como para obtener la información. Esta información se proporciona como un parámetro adicional en la función de consulta (que opcionalmente se puede reemplazar al llamar a las funciones o) (getNextPageParam , getPreviousPageParam , fetchNextPage , fetchPreviousPage)\n- Ahora está disponible un valor booleano y es si devuelve un valor distinto de  (hasNextPage , true , getNextPageParam , undefined)\n- Ahora está disponible un valor booleano y es si devuelve un valor distinto de  (hasPreviousPage , true , getPreviousPageParam , undefined)\n- Los booleanos y ahora están disponibles para distinguir entre un estado de actualización en segundo plano y un estado de carga más (isFetchingNextPage , isFetchingPreviousPage)\n"},{"tag":"md","inner":"**Nota**: Cuando utilice opciones como o en su consulta, asegúrese de que cuando reestructure sus datos que todavía incluyen y propiedades, de lo contrario sus cambios serán sobrescritos por la consulta en su retorno. initialData , select , data.pages , data.pageParams"},{"tag":"h2","inner":"Ejemplo"},{"tag":"md","inner":"Supongamos que tenemos una API que devuelve páginas de 3 a la vez basadas en un índice junto con un cursor que se puede usar para obtener el siguiente grupo de proyectos: (projects , cursor)\n"},{"tag":"html","inner":"1 fetch('/api/projects?cursor=0')\n2 // { data: [...], nextCursor: 3}\n3 fetch('/api/projects?cursor=3')\n4 // { data: [...], nextCursor: 6}\n5 fetch('/api/projects?cursor=6')\n6 // { data: [...], nextCursor: 9}\n7 fetch('/api/projects?cursor=9')\n8 // { data: [...] }"},{"tag":"md","inner":"Con esta información, podemos crear una interfaz de usuario \"Cargar más\" mediante:\n\n- Esperando para solicitar el primer grupo de datos por defecto (useInfiniteQuery)\n- Devolver la información para la siguiente consulta en (getNextPageParam)\n- Función de llamada fetchNextPage\n"},{"tag":"md","inner":"**Nota**: Es muy importante que no llame con argumentos a menos que desee que anulen los datos devueltos por la función. por ejemplo, no haga esto: ya que esto enviaría el evento onClick a la función. (fetchNextPage , pageParam , getNextPageParam , <button onClick={fetchNextPage} /> , fetchNextPage)\n"},{"tag":"html","inner":"1 import { useInfiniteQuery } from 'react-query'\n2\n3 function Projects() {\n4  const fetchProjects = ({ pageParam = 0 }) =>\n5    fetch('/api/projects?cursor=' + pageParam)\n6\n7  const {\n8    data,\n9    error,\n10    fetchNextPage,\n11    hasNextPage,\n12    isFetching,\n13    isFetchingNextPage,\n14    status,\n15  } = useInfiniteQuery('projects', fetchProjects, {\n16    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n17  })\n18\n19  return status === 'loading' ? (\n20    <p>Loading...</p>\n21  ) : status === 'error' ? (\n22    <p>Error: {error.message}</p>\n23  ) : (\n24    <>\n25      {data.pages.map((group, i) => (\n26        <React.Fragment key={i}>\n27          {group.projects.map(project => (\n28            <p key={project.id}>{project.name}</p>\n29          ))}\n30        </React.Fragment>\n31      ))}\n32      <div>\n33        <button\n34          onClick={() => fetchNextPage()}\n35          disabled={!hasNextPage || isFetchingNextPage}\n36        >\n37          {isFetchingNextPage\n38            ? 'Loading more...'\n39            : hasNextPage\n40            ? 'Load More'\n41            : 'Nothing more to load'}\n42        </button>\n43      </div>\n44      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>\n45    </>\n46  )\n47 }\n"},{"tag":"md","inner":"Cuando una consulta infinita se convierte y necesita ser reacondicionada, cada grupo se recupera, comenzando por el primero. Esto garantiza que incluso si los datos subyacentes están mutados, no estamos usando cursores obsoletos y potencialmente obteniendo duplicados u omitiendo registros. Si los resultados de una consulta infinita se eliminan alguna vez de queryCache, la paginación se reinicia en el estado inicial y solo se solicita el grupo inicial. (stale , sequentially)\n\n**refetchPage**\n\nSi sólo desea recuperar activamente un subconjunto de todas las páginas, puede pasar la función a devuelto desde . (refetchPage , refetch , useInfiniteQuery)"},{"tag":"html","inner":"1 const { refetch } = useInfiniteQuery('projects', fetchProjects, {\n2  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n3 })\n4\n5 // only refetch the first page\n6 refetch({ refetchPage: (page, index) => index === 0 })\n"},{"tag":"md","inner":"También puede pasar esta función como parte del 2º argumento () a queryClient.refetchQueries, queryClient.invalidateQueries o **queryClient.resetQueries**.  (queryFilters)\n\n**Firma**\n\n- (refetchPage: (page: TData, index: number, allPages: TData[]) => boolean)\n\nLa función se ejecuta para cada página, y sólo las páginas donde esta función devuelve serán reacondicionadas. (true)\n"},{"tag":"h2","inner":"¿Qué sucede si necesito pasar información personalizada a mi función de consulta?"},{"tag":"md","inner":"De forma predeterminada, la variable devuelta se proporcionará a la función de consulta, pero en algunos casos, es posible que desee invalidarla. Puede pasar variables personalizadas a la función que anulará la variable predeterminada de la siguiente manera: (getNextPageParam , fetchNextPage)\n"},{"tag":"html","inner":"1 function Projects() {\n2  const fetchProjects = ({ pageParam = 0 }) =>\n3    fetch('/api/projects?cursor=' + pageParam)\n4\n5  const {\n6    status,\n7    data,\n8    isFetching,\n9    isFetchingNextPage,\n10    fetchNextPage,\n11    hasNextPage,\n12  } = useInfiniteQuery('projects', fetchProjects, {\n13    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n14  })\n15\n16  // Pass your own page param\n17  const skipToCursor50 = () => fetchNextPage({ pageParam: 50 })\n18 }\n"},{"tag":"h2","inner":"¿Qué pasa si quiero implementar una lista infinita bidireccional?\n"},{"tag":"md","inner":"Las listas bidireccionales se pueden implementar mediante el , y las propiedades y funciones. (getPreviousPageParam , fetchPreviousPage , hasPreviousPage , isFetchingPreviousPage)\n"},{"tag":"html","inner":"1 useInfiniteQuery('projects', fetchProjects, {\n2  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n3  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n4 })\n"},{"tag":"h2","inner":"¿Qué sucede si quiero mostrar las páginas en orden invertido?\n"},{"tag":"md","inner":"A veces es posible que desee mostrar las páginas en orden invertido. Si este es el caso, puede utilizar la opción: (select)\n"},{"tag":"html","inner":"1 useInfiniteQuery('projects', fetchProjects, {\n2  select: data => ({\n3    pages: [...data.pages].reverse(),\n4    pageParams: [...data.pageParams].reverse(),\n5  }),\n6 })\n"},{"tag":"h2","inner":"¿Qué sucede si quiero actualizar manualmente la consulta infinita?\n"},{"tag":"md","inner":"Eliminación manual de la primera página:\n"},{"tag":"html","inner":"1 queryClient.setQueryData('projects', data => ({\n2  pages: data.pages.slice(1),\n3  pageParams: data.pageParams.slice(1),\n4 }))"},{"tag":"p","inner":"Eliminar manualmente un solo valor de una página individual:\n"},{"tag":"html","inner":"1 const newPagesArray = oldPagesArray?.pages.map((page) =>\n2  page.filter((val) => val.id !== updatedId)\n3 ) ?? []\n4\n5 queryClient.setQueryData('projects', data => ({\n6  pages: newPagesArray,\n7  pageParams: data.pageParams,\n8 }))\n"},{"tag":"p","inner":"¡Asegúrese de mantener la misma estructura de datos de páginas y pageParams!\n"}]