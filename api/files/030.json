[{"tag":"md","inner":""},{"tag":"h1","inner":"Migración a React Query 3\n"},{"tag":"md","inner":"Las versiones anteriores de React Query fueron increíbles y trajeron algunas características nuevas y sorprendentes, más magia y una mejor experiencia general a la biblioteca. También trajeron una adopción masiva y también una gran cantidad de fuego refinado (problemas / contribuciones) a la biblioteca y sacaron a la luz algunas cosas que necesitaban más pulido para hacer que la biblioteca fuera aún mejor. v3 contiene ese mismo pulido.\n"},{"tag":"h2","inner":"Visión general\n"},{"tag":"md","inner":"- Configuración de caché más escalable y comprobable\n- Mejor compatibilidad con SSR\n- Data-lag (anteriormente use PaginatedQuery) en cualquier lugar!\n- Consultas infinitas bidireccionales\n- ¡Selectores de datos de consulta!\n- Configurar completamente los valores predeterminados para consultas y/o mutaciones antes de su uso\n- Más granularidad para la optimización de renderizado opcional\n- ¡Nuevo gancho! (Ejecución de consultas paralelas de longitud variable) (useQueries)\n- ¡Soporte de filtro de consulta para el gancho! (useIsFetching())\n- Soporte de reintento/desconexión/reproducción para mutaciones\n- Observar consultas/mutaciones fuera de React\n- ¡Utilice la lógica central de React Query en cualquier lugar que desee!\n- Devtools empaquetados/coubicados a través de (react-query/devtools)\n- Persistencia de caché en el almacenamiento web (experimental a través y react-query/persistQueryClient-experimental , react-query/createWebStoragePersistor-experimental)\n"},{"tag":"h2","inner":"Cambios de última hora\n"},{"tag":"md","inner":"**El se ha dividido en un nivel inferior e instancias**. (QueryCache , QueryClient , QueryCache , MutationCache)\n\nEl contiene todas las consultas, contiene todas las mutaciones y se puede utilizar para establecer la configuración e interactuar con ellas. (QueryCache , MutationCache , QueryClient)\n\nEsto tiene algunos beneficios:\n\n- Permite diferentes tipos de cachés.\n- Varios clientes con diferentes configuraciones pueden usar la misma memoria caché.\n- Los clientes se pueden usar para realizar un seguimiento de las consultas, que se pueden usar para cachés compartidas en SSR.\n- La API de cliente está más enfocada hacia el uso general.\n- Más fácil de probar los componentes individuales.\n\nAl crear un , a y se crean automáticamente para usted si no los proporciona. (new QueryClient() , QueryCache , MutationCache)\n"},{"tag":"html","inner":"1 import { QueryClient } from 'react-query'\n2\n3 const queryClient = new QueryClient()\n"},{"tag":"md","inner":"(ReactQueryConfigProvider) **y ambos han sido reemplazados por** (ReactQueryCacheProvider , QueryClientProvider)\n\nLas opciones predeterminadas para consultas y mutaciones ahora se pueden especificar en: (QueryClient)\n"},{"tag":"md","inner":"**Observe que ahora es defaultOptions en lugar de defaultConfig**\n"},{"tag":"html","inner":"1 const queryClient = new QueryClient({\n2  defaultOptions: {\n3    queries: {\n4      // query options\n5    },\n6    mutations: {\n7      // mutation options\n8    },\n9  },\n10 })\n"},{"tag":"md","inner":"El componente ahora se usa para conectar a su aplicación: (QueryClientProvider , QueryClient)\n"},{"tag":"html","inner":"1 import { QueryClient, QueryClientProvider } from 'react-query'\n2\n3 const queryClient = new QueryClient()\n4\n5 function App() {\n6  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n7 }\n"},{"tag":"md","inner":"**El valor predeterminado ha desaparecido. ¡De verdad esta vez!** (QueryCache)\n\nComo se señaló anteriormente con una obsolescencia, ya no hay un valor predeterminado que se cree o exporte desde el paquete principal. Debe crear el suyo propio a través de new QueryClient() o new QueryCache() **(que luego puede pasar al** (nuevo QueryClient({ queryCache }) , ) , QueryCache)\n\n**Se ha eliminado la utilidad obsoleta**. (makeQueryCache)\n\nHa tardado mucho en llegar, pero finalmente se ha ido :)\n\n(QueryCache.prefetchQuery()) **se ha movido a** (QueryClient.prefetchQuery())\n\nLa nueva función es asincrónica, pero **no devuelve los datos de la consulta**. Si necesita los datos, utilice la nueva función (QueryClient.prefetchQuery(), QueryClient.fetchQuery())\n"},{"tag":"html","inner":"1 // Prefetch a query:\n2 await queryClient.prefetchQuery('posts', fetchPosts)\n3\n4 // Fetch a query:\n5 try {\n6  const data = await queryClient.fetchQuery('posts', fetchPosts)\n7 } catch (error) {\n8  // Error handling\n9 }\n"},{"tag":"md","inner":"(ReactQueryErrorResetBoundary) **y han sido sustituidos por y** (QueryCache.resetErrorBoundaries() , QueryErrorResetBoundary , useQueryErrorResetBoundary())\n\nJuntos, estos proporcionan la misma experiencia que antes, pero con un control adicional para elegir qué árboles de componentes desea restablecer. Para obtener más información, consulte:\n\n- QueryErrorResetBoundary\n- useQueryErrorResetBoundary\n\n(QueryCache.getQuery()) **se ha sustituido por** QueryCache.find()\n(QueryCache.find()) ahora debe usarse para buscar consultas individuales desde una caché\n\n(QueryCache.getQueries()) **se ha movido a** (QueryCache.findAll())\n(QueryCache.findAll()) ahora debe usarse para buscar varias consultas desde una memoria caché\n\n(QueryCache.isFetching) **se ha movido a** (QueryClient.isFetching())\n**Observe que ahora es una función en lugar de una propiedad**\n**El gancho ha sido reemplazado por el gancho**. (useQueryCache , useQueryClient)\n\nDevuelve lo proporcionado para su árbol de componentes y no debería necesitar muchos ajustes más allá de un cambio de nombre. (queryClient)\n\n**Las partes/piezas clave de consulta ya no se propagan automáticamente a la función de consulta**.\n\nLas funciones en línea son ahora la forma sugerida de pasar parámetros a las funciones de consulta:\n"},{"tag":"html","inner":"1 // Old\n2 useQuery(['post', id], (_key, id) => fetchPost(id))\n3\n4 // New\n5 useQuery(['post', id], () => fetchPost(id))\n"},{"tag":"md","inner":"Si aún insiste en no usar funciones en línea, puede usar el recién pasado: (QueryFunctionContext)\n"},{"tag":"html","inner":"useQuery(['post', id], context => fetchPost(context.queryKey[1]))\n"},{"tag":"md","inner":"**Los parámetros de página de consulta infinita ahora se pasan a través de** (QueryFunctionContext.pageParam)\n\nAnteriormente se agregaron como el último parámetro de clave de consulta en la función de consulta, pero esto resultó ser difícil para algunos patrones.\n"},{"tag":"html","inner":"// Old\nuseInfiniteQuery(['posts'], (_key, pageParam = 0) => fetchPosts(pageParam))\n\n\n// New\nuseInfiniteQuery(['posts'], ({ pageParam = 0 }) => fetchPosts(pageParam))\n"},{"tag":"md","inner":"**usePaginatedQuery() ha quedado obsoleto en favor de la opción** (keepPreviousData)\n\nLas nuevas opciones están disponibles para ambos y tendrán el mismo efecto de \"retraso\" en sus datos: (keepPreviousData , useQuery , useInfiniteQuery)"},{"tag":"html","inner":"\nimport { useQuery } from 'react-query'\n\n\nfunction Page({ page }) {\n const { data } = useQuery(['page', page], fetchPage, {\n   keepPreviousData: true,\n })\n}\n"},{"tag":"md","inner":"**useInfiniteQuery() ahora es bidireccional**\n\nLa interfaz ha cambiado para admitir completamente listas infinitas bidireccionales. (useInfiniteQuery())\n\n- (options.getFetchMore) ha sido renombrado a (options.getNextPageParam)\n- (queryResult.canFetchMore) ha sido renombrado a (queryResult.hasNextPage)\n- (queryResult.fetchMore) ha sido renombrado a (queryResult.fetchNextPage)\n- (queryResult.isFetchingMore) ha sido renombrado a (queryResult.isFetchingNextPage)\n- Añadida la opción (options.getPreviousPageParam)\n- Añadida la propiedad (queryResult.hasPreviousPage)\n- Añadida la propiedadquery (Result.fetchPreviousPage)\n- Añadido el \n (queryResult.isFetchingPreviousPage)\n- El de una consulta infinita es ahora un objeto que contiene el y el utilizado para obtener las páginas: (data , pages , pageParams , { pages: [data, data, data], pageParams: [...]})\n\nUna dirección:\n"},{"tag":"html","inner":"const {\n data,\n fetchNextPage,\n hasNextPage,\n isFetchingNextPage,\n} = useInfiniteQuery(\n 'projects',\n ({ pageParam = 0 }) => fetchProjects(pageParam),\n {\n   getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n }\n)\n"},{"tag":"md","inner":"Ambas direcciones:\n"},{"tag":"html","inner":"const {\n data,\n fetchNextPage,\n fetchPreviousPage,\n hasNextPage,\n hasPreviousPage,\n isFetchingNextPage,\n isFetchingPreviousPage,\n} = useInfiniteQuery(\n 'projects',\n ({ pageParam = 0 }) => fetchProjects(pageParam),\n {\n   getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n   getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n }\n)\n"},{"tag":"md","inner":"Una dirección invertida:\n"},{"tag":"html","inner":"const {\n data,\n fetchNextPage,\n hasNextPage,\n isFetchingNextPage,\n} = useInfiniteQuery(\n 'projects',\n ({ pageParam = 0 }) => fetchProjects(pageParam),\n {\n   select: data => ({\n     pages: [...data.pages].reverse(),\n     pageParams: [...data.pageParams].reverse(),\n   }),\n   getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n }\n)\n"},{"tag":"md","inner":"**Los datos de consulta infinita ahora contienen la matriz de páginas y pageParams utilizados para obtener esas páginas**.\n\nEsto permite una manipulación más fácil de los datos y los parámetros de página, como, por ejemplo, eliminar la primera página de datos junto con sus parámetros:\n"},{"tag":"html","inner":"queryClient.setQueryData('projects', data => ({\n pages: data.pages.slice(1),\n pageParams: data.pageParams.slice(1),\n}))"},{"tag":"md","inner":"**useMutation ahora devuelve un objeto en lugar de una matriz**\n\nAunque la vieja manera nos dio sentimientos cálidos y difusos de cuando descubrimos por primera vez, no duraron mucho. Ahora el retorno de mutación es un solo objeto.useState"},{"tag":"html","inner":"// Old:\nconst [mutate, { status, reset }] = useMutation()\n\n\n// New:\nconst { mutate, status, reset } = useMutation()\n"},{"tag":"md","inner":"**mutation.mutate Ya no devolver una promesa**\n\n- La variable se ha cambiado a la función ([mutate] , mutation.mutate)\n- Añadida la función (mutation.mutateAsync)\n\nRecibimos muchas preguntas sobre este comportamiento, ya que los usuarios esperaban que la promesa se comportara como una promesa regular.\n\nDebido a esto, la función ahora se divide en una función y. (mutate , mutate , mutateAsync)\n\nLa función se puede utilizar cuando se utilizan devoluciones de llamada: (mutate)\n"},{"tag":"html","inner":"const { mutate } = useMutation(addTodo)\n\n\nmutate('todo', {\n onSuccess: data => {\n   console.log(data)\n },\n onError: error => {\n   console.error(error)\n },\n onSettled: () => {\n   console.log('settled')\n },\n})\n"},{"tag":"md","inner":"La función se puede utilizar cuando se utiliza async/await: mutateAsync\n"},{"tag":"html","inner":"const { mutateAsync } = useMutation(addTodo)\n\n\ntry {\n const data = await mutateAsync('todo')\n console.log(data)\n} catch (error) {\n console.error(error)\n} finally {\n console.log('settled')\n}\n"},{"tag":"md","inner":"**La sintaxis del objeto para useQuery ahora usa una configuración contraída:**\n"},{"tag":"html","inner":"// Old:\nuseQuery({\n queryKey: 'posts',\n queryFn: fetchPosts,\n config: { staleTime: Infinity },\n})\n\n\n// New:\nuseQuery({\n queryKey: 'posts',\n queryFn: fetchPosts,\n staleTime: Infinity,\n})\n"},{"tag":"md","inner":"**Si se establece, la opción QueryOptions.enabled debe ser booleana (true / false)**\n\nLa opción de consulta ahora sólo deshabilitará una consulta cuando el valor sea . Si es necesario, los valores se pueden convertir con o y se producirá un error útil si se pasa un valor no booleano. (enabled , false , !!userId , Boolean(userId))\n\n**Se ha quitado la opción QueryOptions.initialStale**\n\nLa opción de consulta se ha eliminado y los datos iniciales ahora se tratan como datos normales. Lo que significa que si se proporciona, la consulta se volverá a obtener en el montaje de forma predeterminada. Si no desea volver a recuperar inmediatamente, puede definir un archivo. (initialStale , initialData , staleTime)\n\n**La opción ha sido sustituida por\n(QueryOptions.forceFetchOnMount , refetchOnMount: 'always)** \n\nHonestamente, estábamos acumulando demasiadas opciones, así que esto debería limpiar las cosas. (refetchOn____)\n\n**Las opciones ahora sólo se aplican a su componente primario en lugar de a todos los observadores de consulta QueryOptions.refetchOnMount**\n\nCuando se estableció en cualquier componente adicional se impidió volver a buscar en el montaje. En la versión 3, solo el componente donde se ha establecido la opción no se recuperará en el montaje. (refetchOnMount , false)\n\n**El se ha eliminado en favor del nuevo objeto. (QueryOptions.queryFnParamsFilter , QueryFunctionContext)**\n\nLa opción se ha quitado porque las funciones de consulta ahora obtienen un objeto en lugar de la clave de consulta. \n (queryFnParamsFilter , QueryFunctionContext)\n\nLos parámetros aún se pueden filtrar dentro de la propia función de consulta, ya que también contiene la clave de (consulta.QueryFunctionContext)\n\n**La opción ha sido reemplazada por las nuevas y opciones. (QueryOptions.notifyOnStatusChange , notifyOnChangeProps , notifyOnChangePropsExclusions)**\n\nCon estas nuevas opciones es posible configurar cuándo un componente debe volver a renderizarse a nivel granular.\n\nVuelva a renderizar sólo cuando cambien las propiedades o: (data , error)\n"},{"tag":"html","inner":"import { useQuery } from 'react-query'\n\n\n\nfunction User() {\n const { data } = useQuery('user', fetchUser, {\n   notifyOnChangeProps: ['data', 'error'],\n })\n return <div>Username: {data.username}</div>\n}\n"},{"tag":"md","inner":"Impedir que se vuelva a representar cuando cambie la propiedad: (isStale)\n"},{"tag":"html","inner":"import { useQuery } from 'react-query'\n\n\nfunction User() {\n const { data } = useQuery('user', fetchUser, {\n   notifyOnChangePropsExclusions: ['isStale'],\n })\n return <div>Username: {data.username}</div>\n}"},{"tag":"md","inner":"**Se ha cambiado el nombre de la función a (QueryResult.clear() , QueryResult.remove())**\n\nAunque se llamaba , realmente solo eliminó la consulta de la caché. El nombre ahora coincide con la funcionalidad. (clear)\n\n**La propiedad se ha dividido en y propiedades (QueryResult.updatedAt , QueryResult.dataUpdatedAt , QueryResult.errorUpdatedAt)**\n\nDebido a que los datos y los errores pueden estar presentes al mismo tiempo, la propiedad se ha dividido en y. (updatedAt , dataUpdatedAt , errorUpdatedAt)\n\n**(setConsole()) ha sido reemplazada por la nueva función (setLogger())**\n"},{"tag":"html","inner":"import { setLogger } from 'react-query'\n\n\n// Log with Sentry\nsetLogger({\n error: error => {\n   Sentry.captureException(error)\n },\n})\n\n\n// Log with Winston\nsetLogger(winston.createLogger())\n"},{"tag":"md","inner":"**React Native ya no requiere anular el registrador**\n\nPara evitar mostrar pantallas de error en React Native cuando falla una consulta, fue necesario cambiar manualmente la consola:\n"},{"tag":"html","inner":"import { setConsole } from 'react-query'\n\n\nsetConsole({\n log: console.log,\n warn: console.warn,\n error: console.warn,\n})\n"},{"tag":"md","inner":"En la versión 3 esto se hace automáticamente cuando se utiliza React Query en React Native.\n\n**Mecanografiado**  \n(QueryStatus)  se ha cambiado de un tipo de enumeración a un tipo de unión\n\nPor lo tanto, si estaba comprobando la propiedad status de una consulta o mutación con una propiedad de enumeración QueryStatus, tendrá que comprobarla ahora con el literal de cadena que la enumeración tenía anteriormente para cada propiedad.\n\nPor lo tanto, debe cambiar las propiedades de enumeración a su literal de cadena equivalente, como este:\n\n- QueryStatus.Idle -> 'idle'\n- QueryStatus.Loading -> 'loading'\n- QueryStatus.Error -> 'error'\n- QueryStatus.Success -> 'success'\n\nAquí hay un ejemplo de los cambios que tendría que hacer:\n"},{"tag":"html","inner":"- import { useQuery, QueryStatus } from 'react-query';\n+ import { useQuery } from 'react-query';\nconst { data, status } = useQuery(['post', id], () => fetchPost(id))\n\n\n- if (status === QueryStatus.Loading) {\n+ if (status === 'loading') {\n...\n}\n\n\n- if (status === QueryStatus.Error) {\n+ if (status === 'error') {\n...\n}\n"},{"tag":"md","inner":"**Nuevas características**  \nSelectores de datos de consulta\n\nLos ganchos y ahora tienen una opción para seleccionar o transformar partes del resultado de la consulta. (useQuery , useInfiniteQuery , select)\n"},{"tag":"html","inner":"import { useQuery } from 'react-query'\n\n\nfunction User() {\n const { data } = useQuery('user', fetchUser, {\n   select: user => user.username,\n })\n return <div>Username: {data}</div>\n}\n"},{"tag":"md","inner":"Establezca la opción en para volver a renderizar solo cuando cambien los datos seleccionados. (notifyOnChangeProps , ['data', 'error'])\n\n**El enlace useQueries(), para la ejecución de consultas paralelas de longitud variable**\n\n¿Te gustaría poder correr en bucle? Las reglas de los ganchos dicen que no, pero con el nuevo gancho, ¡puedes! (useQuery , useQueries())\n"},{"tag":"html","inner":"import { useQueries } from 'react-query'\n\n\nfunction Overview() {\n const results = useQueries([\n   { queryKey: ['post', 1], queryFn: fetchPost },\n   { queryKey: ['post', 2], queryFn: fetchPost },\n ])\n return (\n   <ul>\n     {results.map(({ data }) => data && <li key={data.id}>{data.title})</li>)}\n   </ul>\n )\n}\n"},{"tag":"md","inner":"**Reintento/mutaciones fuera de línea**\n\nDe forma predeterminada, React Query no reintentará una mutación por error, pero es posible con la opción: (retry)\n"},{"tag":"html","inner":"const mutation = useMutation(addTodo, {\n retry: 3,\n})\n"},{"tag":"md","inner":"Si las mutaciones fallan porque el dispositivo está fuera de línea, se volverán a intentar en el mismo orden cuando el dispositivo se vuelva a conectar.\n\n**Mutaciones persistentes**\n\nLas mutaciones ahora pueden persistir hasta el almacenamiento y reanudarse en un momento posterior. Se puede encontrar más información en la documentación de mutaciones.\n\n**QueryObserver**\n\nA se puede utilizar para crear y/o ver una consulta: (QueryObserver)\n"},{"tag":"html","inner":"const observer = new QueryObserver(queryClient, { queryKey: 'posts' })\n\n\nconst unsubscribe = observer.subscribe(result => {\n console.log(result)\n unsubscribe()\n})\n"},{"tag":"md","inner":"**InfiniteQueryObserver**\n\nA se puede utilizar para crear y/o ver una consulta infinita: (InfiniteQueryObserver)\n\n\n"},{"tag":"html","inner":"const observer = new InfiniteQueryObserver(queryClient, {\n queryKey: 'posts',\n queryFn: fetchPosts,\n getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,\n getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,\n})\n\n\nconst unsubscribe = observer.subscribe(result => {\n console.log(result)\n unsubscribe()\n})\n"},{"tag":"md","inner":"**QueriesObserver**\n\nA se puede utilizar para crear y/o ver varias consultas: QueriesObserver\n"},{"tag":"html","inner":"const observer = new QueriesObserver(queryClient, [\n { queryKey: ['post', 1], queryFn: fetchPost },\n { queryKey: ['post', 2], queryFn: fetchPost },\n])\n\n\nconst unsubscribe = observer.subscribe(result => {\n console.log(result)\n unsubscribe()\n})\n"},{"tag":"md","inner":"**Establecer opciones predeterminadas para consultas específicas**\n\nEl método se puede utilizar para establecer opciones predeterminadas para consultas específicas: (QueryClient.setQueryDefaults())\n"},{"tag":"html","inner":"queryClient.setQueryDefaults('posts', { queryFn: fetchPosts })\n\n\nfunction Component() {\n const { data } = useQuery('posts')\n}\n"},{"tag":"md","inner":"**Establecer opciones predeterminadas para mutaciones específicas**\n\nEl método se puede utilizar para establecer opciones predeterminadas para mutaciones específicas: (QueryClient.setMutationDefaults())\n"},{"tag":"html","inner":"queryClient.setMutationDefaults('addPost', { mutationFn: addPost })\n\n\nfunction Component() {\n const { mutate } = useMutation('addPost')\n}\n"},{"tag":"md","inner":"**useIsFetching()**\n\nEl gancho ahora acepta filtros que se pueden usar, por ejemplo, solo para mostrar un spinner para cierto tipo de consultas: (useIsFetching())\n"},{"tag":"html","inner":"const fetches = useIsFetching(['posts'])\n"},{"tag":"md","inner":"**Separación del núcleo**\n\nEl núcleo de React Query ahora está completamente separado de React, lo que significa que también se puede usar de forma independiente o en otros marcos. Utilice el punto de entrada para importar solo la funcionalidad principal: (react-query/core)\n"},{"tag":"html","inner":"import { QueryClient } from 'react-query/core'\n"},{"tag":"h2","inner":"Devtools ahora son parte del repositorio principal y el paquete npm\n"},{"tag":"md","inner":"Las devtools ahora se incluyen en el propio paquete bajo la importación . Simplemente reemplace las importaciones con  (react-query , react-query/devtools , react-query-devtools , react-query/devtools)\n"}]