[{"tag":"h1","inner":"Comparaci√≥n | React Query vs SWR vs Apollo vs RTK Query vs React Router"},{"tag":"md","inner":"Esta tabla de comparaci√≥n se esfuerza por ser lo m√°s precisa e imparcial posible. Si usa alguna de estas bibliotecas y cree que la informaci√≥n podr√≠a mejorarse, no dude en sugerir cambios (con notas o evidencia de reclamos) usando el enlace \"Editar esta p√°gina en Github\" en la parte inferior de esta p√°gina.\n\nTecla de caracter√≠stica/capacidad:\n\n- ‚úÖ 1¬™ clase, integrado y listo para usar sin configuraci√≥n o c√≥digo agregado\n- üü° Compatible, pero como una 3¬™ parte no oficial o biblioteca / contribuci√≥n comunitaria\n- üî∂ Compatible y documentado, pero requiere c√≥digo de usuario adicional para implementarse\n- üõë No est√° oficialmente respaldado o documentado.\n"},{"tag":"md","inner":"VER LO DE IMAGENES / TABLA\n\n"},{"tag":"h1","inner":"Notas"},{"tag":"md","inner":"**1 Datos de consulta retrasados** - React Query proporciona una forma de continuar viendo los datos de una consulta existente mientras se carga la siguiente consulta (similar a la misma UX que el suspenso pronto proporcionar√° de forma nativa). Esto es extremadamente importante cuando se escriben interfaces de usuario de paginaci√≥n o interfaces de usuario de carga infinita en las que no desea mostrar un estado de carga completa cada vez que se solicita una nueva consulta. Otras bibliotecas no tienen esta capacidad y representan un estado de carga dura para la nueva consulta (a menos que se haya cargado previamente), mientras se carga la nueva consulta.\n\n**2 Optimizaci√≥n de renderizado** - React Query tiene un excelente rendimiento de renderizado. Solo volver√° a representar los componentes cuando se actualice una consulta. Por ejemplo, porque tiene nuevos datos, o para indicar que est√° buscando. React Query tambi√©n agrupa las actualizaciones por lotes para asegurarse de que su aplicaci√≥n solo se vuelva a representar una vez cuando varios componentes est√©n usando la misma consulta. Si s√≥lo le interesan las propiedades o, puede reducir a√∫n m√°s el n√∫mero de renderizaciones estableciendo en . Se establece para realizar un seguimiento autom√°tico de los campos a los que se accede y solo volver a renderizarlos si uno de ellos cambia. data , error , notifyOnChangeProps , ['data', 'error'] , notifyOnChangeProps: 'tracked'\n\n**3 Coincidencia parcial de consultas** - Debido a que React Query utiliza la serializaci√≥n de claves de consulta deterministas, esto le permite manipular grupos variables de consultas sin tener que conocer cada clave de consulta individual que desea coincidir, por ejemplo. Puede recuperar todas las consultas que comienzan con en su clave, independientemente de las variables, o puede dirigirse a consultas espec√≠ficas con (o sin) variables o propiedades anidadas, e incluso usar una funci√≥n de filtro para que solo coincida con las consultas que superan sus condiciones espec√≠ficas. todos\n\n**4 Configuraci√≥n de consulta previa al uso** - Este es simplemente un nombre elegante para poder configurar c√≥mo se comportar√°n las consultas y las mutaciones antes de ser utilizadas. Por ejemplo, una consulta se puede configurar completamente con valores predeterminados de antemano y cuando llegue el momento de usarla, solo es necesario, en lugar de ser requerido para pasar el fetcher y / o las opciones con cada uso. SWR tiene una forma parcial de esta caracter√≠stica al permitirle preconfigurar un fetcher predeterminado, pero solo como un fetcher global, no por consulta y definitivamente no para mutaciones. useQuery(key)\n\n**5 Recuperaci√≥n autom√°tica despu√©s de la mutaci√≥n** - Para que ocurra una recuperaci√≥n verdaderamente autom√°tica despu√©s de que ocurra una mutaci√≥n, es necesario un esquema (como el que proporciona graphQL) junto con heur√≠sticas que ayuden a la biblioteca a saber c√≥mo identificar entidades individuales y tipos de entidades en ese esquema.\n\n**6 Almacenamiento en cach√© normalizado** - React Query, SWR y RTK-Query actualmente no admiten el almacenamiento en cach√© normalizado autom√°ticamente que describe el almacenamiento de entidades en una arquitectura plana para evitar cierta duplicaci√≥n de datos de alto nivel.\n\n**7 Modo inmutable de SWR** - SWR se env√≠a con un modo \"inmutable\" que le permite obtener una consulta solo una vez durante la vida √∫til de la memoria cach√©, pero a√∫n no tiene el concepto de tiempo obsoleto o revalidaci√≥n autom√°tica condicional\n\n**8 Persistencia de cach√© de React Router** - React Router no almacena en cach√© los datos m√°s all√° de las rutas actualmente coincidentes. Si se deja una ruta, sus datos se pierden.\n\n"},{"tag":"md","inner":""}]